{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>NeSI ephemeral training environments, running on Flexi HPC, deployed using Terraform and Ansible and using Open OnDemand as the user interface.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>The training environment consists of multiple VMs:</p> <ul> <li>web node VM<ul> <li>running the Open OnDemand web node software</li> <li>LDAP client</li> </ul> </li> <li>services node VM<ul> <li>LDAP server</li> <li>Keycloak</li> <li>NFS server sharing training user home directories</li> </ul> </li> <li>kubernetes cluster<ul> <li>the users' Open OnDemand apps run here (JupyterLab, RStudio, etc.)</li> <li>each node in the cluster is an LDAP client</li> </ul> </li> </ul>"},{"location":"#apps","title":"Apps","text":"<p>Open OnDemand interactive applications, such as JupyterLab and RStudio, are used for the training courses. More information about apps can be found here.</p>"},{"location":"#user-accounts","title":"User accounts","text":"<p>Within the training environment we create two different types of user accounts, training users and trainer users, with randomly generated passwords.</p> <ul> <li>training accounts<ul> <li>isolated accounts that can only access their own home directory</li> </ul> </li> <li>trainer accounts<ul> <li>have read-only access to training user home directories, to monitor progress and assist</li> <li>can use the browser based terminal from the OnDemand web interface</li> </ul> </li> </ul>"},{"location":"deployment/","title":"Deployment","text":"<p>TODO:</p> <ul> <li>process, configuring (num users, etc)</li> </ul>"},{"location":"known-issues/","title":"Known issues and limitations","text":""},{"location":"known-issues/#timeouts-on-login-page","title":"Timeouts on login page","text":"<p>If you leave the login page open for a while without logging in you may encounter a timeout error when you do eventually login. Opening a new tab and navigating to the webnode URL should fix this. It would be a good idea to login immediately after opening the training environment URL until we have fixed this timeout issue.</p>"},{"location":"known-issues/#sharing-the-link-to-the-training-environment","title":"Sharing the link to the training environment","text":"<p>Make sure you only share webnode URL, which will look like \"https://name-ood-webnode.data.nesi.org.nz\".</p> <p>Do not share the services URL (which is the URL you see on the login screen) that looks like \"https://name-ood-services.data.nesi.org.nz\". If you share link it will almost certainly not work for others.</p>"},{"location":"notes-for-trainers/","title":"Notes for trainers","text":""},{"location":"notes-for-trainers/#viewing-training-users-files","title":"Viewing training user's files","text":"<p>All trainer users should have read access on all training users home directories to help with debugging issues, checking progress, etc. The paths to the home directories will look like:</p> <pre><code>/home/shared/training1\n/home/shared/training2\n...\n</code></pre>"},{"location":"notes-for-trainers/#recommended-browsers","title":"Recommended browsers","text":"<p>Following upstream Open OnDemand documentation we highly recommend the use of Chrome, Firefox or Edge.</p> <p>Other browsers and extensions (ad blockers, etc) could cause issues. For example, we have observed problems with the DuckDuckGo browser, which blocked the password from being passed transparently to JupyterLab, causing an \"Invalid credentials\" error.</p> <p></p>"},{"location":"notes-for-trainers/#session-limits","title":"Session limits","text":"<p>Each user (both trainer and training users) are limited to one running session (app) at a time, to ensure there are enough resources for everyone to run something. To restart an app, or stop an app so that you can start another one, you should:</p> <ul> <li>browse to the \"My Interactive Sessions\" tab</li> <li>click \"Delete\" on the running session</li> <li>important: wait for approx one minute for the underlying pod to get properly deleted by the kubernetes cluster (otherwise you will get an error at the next step)</li> <li>launch the new app</li> </ul> <p>If you try to launch the new app too soon after deleting, or while a session is already running, you will get a Failed to submit session error.</p>"},{"location":"notes-for-trainers/#browser-based-terminal-app","title":"Browser based terminal app","text":"<p>The browser based terminal in the OnDemand web interface runs on the webnode and can be used to monitor progress and assist training users from outside the apps. These terminal sessions run on the OnDemand web node and do not have any resource restrictions, so nothing resource intensive should be run there. Only trainer users can use this feature; if training users try to use it they will get an error.</p>"},{"location":"notes-for-trainers/#list-running-sessions","title":"List running sessions","text":"<p>You can list running sessions, for example to see how many training users have successfully started a session, via the browser based terminal app using the following commands:</p> <ul> <li><code>nesi-get-pods</code></li> <li><code>nesi-get-pods-wide</code></li> </ul> <p>These will list all pods on the kubernetes cluster. You could filter them by looking just for training user pods and just those that are currently running, for example:</p> <pre><code>nesi-get-pods | grep user-training | grep Running\n</code></pre> <p>will show just training user pods that are running, while</p> <pre><code>nesi-get-pods | grep user-\n</code></pre> <p>will show both training and trainer pods, including those in all states (not just running).</p>"},{"location":"notes-for-trainers/#known-issues-and-limitations","title":"Known issues and limitations","text":"<p>See known issues</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Some common errors are listed on this page.</p>"},{"location":"troubleshooting/#failed-to-submit-session","title":"Failed to submit session","text":"<p>Seeing an error similar to the above image is usually caused by trying to start a new session when one is already running.</p> <p>Follow the steps here to stop your existing session before starting the new one.</p>"},{"location":"apps/","title":"Apps","text":""},{"location":"apps/#overview","title":"Overview","text":"<p>Open OnDemand app development is described in detail in their documentation.</p> <p>In particular, the training environment uses a kubernetes cluster for running the apps, so the apps are developed similarly to the kubernetes examples on the Open OnDemand website:</p> <ul> <li>Add a Jupyter App on a Kubernetes Cluster</li> <li>Add a Jupyter App on a Kubernetes Cluster that behaves like HPC compute</li> </ul> <p>On the following pages are some examples of apps that have been developed to run on the training environment.</p>"},{"location":"apps/#key-points","title":"Key points","text":"<ul> <li>Apps are created as docker images</li> <li>Apps are set up as LDAP clients so training and trainer users are identified correctly within the container<ul> <li>the nslcd socket from the kubernetes worker node is bound into the container at the correct location</li> <li>the /etc/nsswitch.conf file from the kubernetes worked node is bound into the container</li> <li>LDAP client packages are installed inside the container (nslcd, etc)</li> </ul> </li> <li>All home directories are bound into the container (so trainer users can access training users' homes from within the apps if needed)</li> </ul>"},{"location":"apps/#general-structure-of-open-ondemand-apps","title":"General structure of Open OnDemand apps","text":"<p>TODO</p>"},{"location":"apps/example-conda-jupyterlab-ml101/","title":"Example: conda based JupyterLab app for ML101","text":"<p>TODO...</p>"},{"location":"apps/example-rstudio-rna-seq/","title":"RStudio based app for RNA-Seq","text":""},{"location":"apps/example-rstudio-rna-seq/#overview","title":"Overview","text":"<p>App developed for the RNA-Seq workshop using RStudio.</p>"},{"location":"apps/example-venv-jupyterlab-ml102/","title":"Example: venv based JupyterLab app for ML102","text":"<p>TODO...</p>"},{"location":"tutorials/adding-new-app/","title":"Adding a new app","text":""},{"location":"tutorials/adding-new-app/#overview","title":"Overview","text":"<p>The suggested approach is to copy the existing app that most closely resembles your new app and modify that, we will document this approach here. Some of the existing apps are:</p> <ul> <li>Apptainer workshop app<ul> <li>based on JupyterLab</li> </ul> </li> <li>Intermediate shell workshop app<ul> <li>based on JupyterLab</li> <li>there is a tutorial for this app</li> </ul> </li> <li>Jupyter ML101 app<ul> <li>based on JupyterLab</li> <li>uses Miniconda to install dependencies</li> </ul> </li> <li>Jupyter ML102 app<ul> <li>based on JupyterLab</li> <li>uses Python virtualenv and pip to install dependencies</li> </ul> </li> <li>RStudio RNA-Seq app<ul> <li>based on RStudio</li> <li>includes data files in the docker image</li> <li>uses Miniconda to install some dependencies such as <code>samtools</code> and <code>fastqc</code></li> <li>uses <code>BiocManager</code> and <code>install.packages</code> to install R dependencies</li> </ul> </li> <li>RStudio scRNA-Seq app</li> <li>RStudio intro and intermediate R app</li> </ul>"},{"location":"tutorials/adding-new-app/#what-needs-to-be-changed","title":"What needs to be changed","text":"<p>Here we summarise what is most likely to need to be changed when copying an existing app. Assuming the app your are copying is based on the same web application (i.e. JupyterLab vs RStudio, etc.) then not much should need to change.</p> <ul> <li>view.html.erb<ul> <li>change the line that contains the string Connect to , replacing  with something specific to your app <li>manifest.yml<ul> <li>change the <code>name</code> and <code>description</code></li> </ul> </li> <li>form.yml<ul> <li>adjust <code>cpu</code>, <code>memory</code>, <code>wall_time</code> if needed (can also add/remove any options)</li> </ul> </li> <li>submit.yml.erb<ul> <li>change <code>script.native.container.name</code> to something unique for your app</li> <li>change <code>script.native.container.image</code> to the image that will be built for your app - this should look like your github repo name and include a label/version (you will need to create a git tag for the version you put here)</li> </ul> </li> <li>script/template.sh.erb<ul> <li>copy any data in your image before launching the app, e.g. using something like   <pre><code>rsync --ignore-existing -avz /path/in/docker/image/to/data/ ~/data/\n</code></pre></li> </ul> </li> <li>docker/Dockerfile<ul> <li>add additional packages and install steps (generally not a good idea to remove packages unless you know what you are doing)</li> <li>add any required data</li> </ul> </li> <p>Note about naming your git repo</p> <p>When you copy an existing app repo you should take care when naming your new repository - make sure you do not use underscores - use hyphens instead as github packages do not support package names with underscores and the default github action we include uses the repository name for the package name</p>"},{"location":"tutorials/adding-new-app/#creating-a-tagrelease-of-your-new-app","title":"Creating a tag/release of your new app","text":"<p>In order to deploy your app in the training environment we are going to tag a version/release of it, using git tags.</p> <ol> <li>Update the version label in <code>script.native.container.image</code> in submit.yml.erb to reflect the new version you are about to create, commit that file. For example, here we are going to release version \"v0.2.2\": <code>image: \"ghcr.io/nesi/training-environment-rstudio-rnaseq-app:v0.2.2\"</code></li> <li>Create a tag with that specific version, e.g. <code>git tag -a v0.2.2 -m \"my new release\"</code></li> <li>Push the tags, e.g. <code>git push --tags</code></li> <li>This should trigger a build of the docker image, check the \"Actions\" tab of your GitHub repo and wait for it to complete successfully</li> </ol>"},{"location":"tutorials/adding-new-app/#adding-your-app-to-the-training-environment","title":"Adding your app to the training environment","text":"<p>To add you app to the training environment you need to modify the training-environment repo, specifically the file vars/ondemand-config.yml.example:</p> <ol> <li>Identify the <code>ood_apps</code> section in the file vars/ondemand-config.yml.example</li> <li>This section consists of a number of blocks, one for each app, so add a new block for your new app:     <pre><code>rstudio_rnaseq:\n  k8s_container: ghcr.io/nesi/training-environment-rstudio-rnaseq-app:v0.2.2\n  repo: https://github.com/nesi/training-environment-rstudio-rnaseq-app.git\n  version: 'v0.2.2'\n  enabled: true\n  pre_pull: false\n</code></pre></li> <li>Next time you build the environment the new app should be included</li> </ol> <p>More detail on the keys above follows:</p> <ul> <li><code>rstudio_rnaseq</code> should be set to a unique value in the <code>ood_apps</code> block</li> <li><code>k8s_container</code> must point to the docker image for your app, tagged with the specific version (the git tag you created above)</li> <li><code>repo</code> the github repo for your app</li> <li><code>version</code> should be the git tag you created above</li> <li><code>enabled: true</code> so that your app shows up in ondemand</li> <li><code>pre_pull: false</code> is a good default and can be changed to <code>true</code> when you are using that app in a training</li> </ul> <p>Releasing a new version of your app</p> <p>When you release a new version of your app you need to update both the <code>k8s_container</code> and <code>version</code> values with the new version of your app</p>"},{"location":"tutorials/adding-new-app/#developing","title":"Developing","text":"<p>When developing it can be useful...</p>"},{"location":"tutorials/deployment-on-nesi/","title":"Deployment a training environment","text":"<p>Here we document the process for deploying a training environment on the NeSI Flexi HPC platform.</p> <p>Details of how we have set up the project on Flexi HPC, the github repo, etc. are not covered here.</p>"},{"location":"tutorials/deployment-on-nesi/#clone-the-git-repo","title":"Clone the git repo","text":"<p>Clone the repo if you don't already have it, e.g. using SSH:</p> <pre><code>git clone git@github.com:nesi/training-environment.git\ncd training-environment\n</code></pre> <p>If you have already cloned the repo, make sure you commit or stash any local changes. It is also a good idea to start from the main branch to pick up the latest changes.</p> <pre><code>git stash\ngit checkout main\n</code></pre>"},{"location":"tutorials/deployment-on-nesi/#configure-the-deployment","title":"Configure the deployment","text":"<p>Create a new branch. The branch name will used in the URL for the training environment, so pick something short and relevant to the workshop (no special characters, etc.). For example, ml101, introtor, etc.</p> <pre><code>git checkout -b my-test-env\n</code></pre> <p>We need to edit two files to configure the environment:</p>"},{"location":"tutorials/deployment-on-nesi/#edit-varsondemand-configymlexample","title":"Edit vars/ondemand-config.yml.example","text":"<ul> <li>adjust <code>num_users_create</code> and <code>num_trainers_create</code></li> <li>adjust <code>ood_apps</code> as required<ul> <li>check <code>version</code> and <code>k8s_container</code></li> <li>enable required apps (usually just leave them all enabled, except for containers)</li> <li>set which images to pre-pull (just choose the one you will be using, we have limited space currently on the worker nodes and pre-pulling will fail if you exhaust it)</li> </ul> </li> <li>set <code>enable_pod_prepull</code> to \"true\"<ul> <li>sometimes we have experienced really slow image pulls, this will pre-pull the image and cache it so it is fast to start</li> <li>only pre-pull the app you are actually going to use, don't pre-pull them all as there might not be enough disk space on the worker nodes</li> </ul> </li> <li>set <code>control_plane_flavor</code><ul> <li>usually to <code>balanced1.4cpu8ram</code> for production</li> <li><code>balanced1.2cpu4ram</code> is good for testing</li> </ul> </li> <li>set <code>cluster_worker_count</code> and <code>worker_flavor</code> to have enough capacity for the number of users, e.g.<ul> <li><code>cluster_worker_count: 2</code> and <code>worker_flavor: balanced1.32cpu64ram</code> for up to 30 2cpu4ram sessions</li> <li><code>cluster_worker_count: 3</code> and <code>worker_flavor: balanced1.32cpu64ram</code> for up to 45 2cpu4ram sessions</li> </ul> </li> </ul>"},{"location":"tutorials/deployment-on-nesi/#edit-terraformterraformtfvars","title":"Edit terraform/terraform.tfvars","text":"<ul> <li>adjust <code>services_flavor_id</code><ul> <li><code>e07cfee1-43af-4bf6-baac-3bdf7c1b88f8</code> 4cpu8ram (usually used for testing)</li> <li><code>2d02e6a4-3937-4ed3-951a-8e27867ff53e</code> 8cpu16ram (usually used for production, should be good for around 40-50 users, haven't tested past that)</li> <li><code>674fa81a-69c7-4bf7-b3a9-59989fb63618</code> 16cpu32ram</li> </ul> </li> <li>adjust <code>services_volume_size</code>, must be big enough for all the user home directories plus some extra room</li> <li>adjust <code>webnode_flavor_id</code><ul> <li><code>e07cfee1-43af-4bf6-baac-3bdf7c1b88f8</code> 4cpu8ram (usually used for testing)</li> <li><code>2d02e6a4-3937-4ed3-951a-8e27867ff53e</code> 8cpu16ram (usually used for production, should be good for around 40-50 users, haven't tested past that)</li> <li><code>674fa81a-69c7-4bf7-b3a9-59989fb63618</code> 16cpu32ram</li> </ul> </li> <li>adjust <code>webnode_volume_size</code>, usually leave at 30 GB</li> </ul>"},{"location":"tutorials/deployment-on-nesi/#commit-the-changes","title":"Commit the changes","text":"<p>Commit and push the changes to your branch, e.g.</p> <pre><code>git add terraform/terraform.tfvars vars/ondemand-config.yml.example\ngit commit -m \"configuring environment for XXX workshop\"\ngit push -u origin my-test-env\n</code></pre>"},{"location":"tutorials/deployment-on-nesi/#deploy-the-environment","title":"Deploy the environment","text":"<p>This will change</p> <p>Deployments are currently done via manually triggered GitHub actions.</p> <p>Check there are enough resources</p> <p>Before running a new deployment, let others know what you are planning via Slack to ensure there are enough resources in the training project</p> <ol> <li>Navigate to the deploy environment workflow here</li> <li>Under Run workflow select your branch (make sure you get the correct branch) and click \"Run workflow\"</li> </ol>"},{"location":"tutorials/deployment-on-nesi/#destroy-the-environment","title":"Destroy the environment","text":"<p>To destroy your environment after you have finished using it:</p> <ol> <li>Navigate to the destroy environment workflow here</li> <li>Under Run workflow select your branch (make sure you get the correct branch) and click \"Run workflow\"</li> </ol> <p>Important</p> <p>Double check that you have selected the correct branch</p>"},{"location":"tutorials/deployment-on-nesi/#deploying-vs-destroying","title":"Deploying vs destroying","text":"<p>Many changes can be redeployed on top of an existing deployment rather than destroying and deploying from scratch.</p> <p>For example, with the following changes you can probably just rerun the deployment workflow and the changes will be applied to the existing environment:</p> <ul> <li>add a new app to <code>ood_apps</code></li> <li>change the <code>version</code> of an existing app</li> <li>change the <code>k8s_container</code> of an existing app</li> <li>enable the pod pre-puller</li> <li>add additional users</li> </ul> <p>However, in some cases you will need to destroy the existing environment and deploy a new one from scratch:</p> <ul> <li>change the flavor of the web or services node</li> <li>change the disk space of the web or services node</li> <li>change the number of k8s worker nodes</li> <li>change the flavor of the k8s worker nodes</li> <li>change the control plane flavour</li> </ul> <p>The above lists are not exhaustive, they just provide some examples.</p>"},{"location":"tutorials/jupyterlab-app-for-intermediate-shell-for-bioinformatics/","title":"JupyterLab app for Intermediate Shell for Bioinformatics","text":"<p>This tutorial will show how to create a JupyterLab based app for teaching intermediate shell for bioinformatics.</p> <p>The GitHub repo for the app that this tutorial is based on can be found here.</p> <p>The app has a standard structure for a Kubernetes based Open OnDemand app and the related upstream documentation may be useful:</p> <ul> <li>Add a Jupyter App on a Kubernetes cluster</li> <li>Add a Jupyter App on a Kubernetes cluster that behaves like HPC compute</li> </ul> <p>In this tutorial we will go through the different files in the above repo and how we have customised them for this training app.</p> <p>Files with .erb extension</p> <p>Files with a .erb extension below are run through the Embedded Ruby template engine. If you don't need this you can remove the .erb extension, or add it to files where you need it.</p>"},{"location":"tutorials/jupyterlab-app-for-intermediate-shell-for-bioinformatics/#layout","title":"Layout","text":"<p>The layout of the app looks like:</p> <pre><code>intermediate-shell-app\n\u251c\u2500\u2500 .github\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 workflows\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 build_container.yml\n\u251c\u2500\u2500 docker\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 form.yml\n\u251c\u2500\u2500 icon.png\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 manifest.yml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 submit.yml.erb\n\u251c\u2500\u2500 template\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 script.sh.erb\n\u2514\u2500\u2500 view.html.erb\n</code></pre> <p>In the following sections we go into more detail about each file.</p>"},{"location":"tutorials/jupyterlab-app-for-intermediate-shell-for-bioinformatics/#formyml","title":"form.yml","text":"<p>In the form.yml file we set the name of the cluster that this app should belong to. In our case the cluster is hard-coded in our Open OnDemand deployment to be called <code>my-k8s-cluster</code> so we should never need to change this:</p> <pre><code>cluster: \"my-k8s-cluster\"\n</code></pre> <p>The form section defines some parameters that can be set on the launcher form and used by us to configure the app at run time. Here we define three parameters:</p> <pre><code>form:\n  - cpu\n  - memory\n  - wall_time\n</code></pre> <p>In the attributes section we define how the above parameters should appear to the user on the launcher form. We hard-code the CPU and memory requirements to 2 CPUs and 4 GB RAM, so these options won't appear on the form but they will be available for us to use later (once the user has clicked the launch button):</p> <pre><code>attributes:\n  cpu: 2\n  memory: 4\n</code></pre> <p>The walltime option is configurable by the user (although not enforced by us at the time of writing...). We allow the user to choose a value between 4 and 12 hours and the form will be pre-populated with a default value of 8 hours:</p> <pre><code>attributes:\n  cpu: 2\n  memory: 4\n  wall_time:\n    widget: number_field\n    label: \"Hours\"\n    min: 4\n    max: 12\n    value: 8\n</code></pre> <p>Different widgets are available. See also the upstream documentation.</p> View complete form.yml <pre><code>---\ncluster: \"my-k8s-cluster\"\n\nform:\n  - cpu\n  - memory\n  - wall_time\n\nattributes:\n  cpu: 2\n  memory: 4\n  wall_time:\n    widget: number_field\n    label: \"Hours\"\n    min: 4\n    max: 12\n    value: 8\n</code></pre>"},{"location":"tutorials/jupyterlab-app-for-intermediate-shell-for-bioinformatics/#manifestyml","title":"manifest.yml","text":"<p>The manifest.yml files defines how the app shows up in the user interface, e.g. what name it will have</p> <pre><code>name: Intermediate shell for bioinformatics\n</code></pre> <p>For the training environment we don't need to change the following:</p> <pre><code>category: Interactive Apps\nsubcategory: Servers\nrole: batch_connect\n</code></pre> <p>but can edit the description to be something relevant:</p> <pre><code>description: |\n  This app will launch a Jupyter Lab server for the intermediate shell for bioinformatics workshop\n</code></pre> View complete manifest.yml <pre><code>---\nname: Intermediate shell for bioinformatics\ncategory: Interactive Apps\nsubcategory: Servers\nrole: batch_connect\ndescription: |\n  This app will launch a Jupyter Lab server for the intermediate shell for bioinformatics workshop\n</code></pre>"},{"location":"tutorials/jupyterlab-app-for-intermediate-shell-for-bioinformatics/#submitymlerb","title":"submit.yml.erb","text":"<p>Most of the configuration for the app happens in this file. It will look quite different depending on the type of app, e.g. JupyterLab vs RStudio. Notice the .erb extension which means this file will run through the ERB template engine.</p> <p>The top section of the file (above the \"---\") should not need to be changed. In this section we set some ruby variables that are used in the templates later on, e.g. a reference to the current user, the IP address of the services node, etc.</p> <pre><code>&lt;%\n   pwd_cfg = \"c.ServerApp.password=u\\'sha1:${SALT}:${PASSWORD_SHA1}\\'\"\n   host_port_cfg = \"c.ServerApp.base_url=\\'/node/${HOST_CFG}/${PORT_CFG}/\\'\"\n\n   configmap_filename = \"ondemand_config.py\"\n   configmap_data = \"c.NotebookApp.port = 8080\"\n   utility_img = \"ghcr.io/nesi/training-environment-k8s-utils:v0.1.0\"\n\n   user = OodSupport::User.new\n\n   services_node = Resolv.getaddress(\"servicesnode\")\n%&gt;\n---\n</code></pre> <p>The config happens in the <code>script:</code> entry, usually the <code>accounting_id</code> and <code>wall_time</code> should not need to change</p> <pre><code>script:\n  accounting_id: \"&lt;%= account %&gt;\"\n  wall_time: \"&lt;%= wall_time.to_i * 3600 %&gt;\"\n</code></pre> <p>Inside the <code>native:</code> entry is where we configure the pod that will run the app on the kubernetes cluster, for example we define the container with:</p> <pre><code>  native:\n    container:\n      name: \"intermshell\"\n      image: \"ghcr.io/nesi/training-environment-jupyter-intermediate-shell-app:v0.3.3\"\n      command: [\"/bin/bash\",\"-l\",\"&lt;%= staged_root %&gt;/job_script_content.sh\"]\n      working_dir: \"&lt;%= Etc.getpwnam(ENV['USER']).dir %&gt;\"\n      restart_policy: 'OnFailure'\n</code></pre> <ul> <li>Using a unique <code>name</code> is a good idea to tell the running apps apart</li> <li><code>image</code> should point the docker image that should be used</li> <li><code>command</code> should not be changed</li> <li><code>working_dir</code> is usually left as the home directory but could be changed</li> <li><code>restart_policy</code> is usually left the same</li> </ul> <p>Note about developing apps</p> <p>When developing an app it can be useful to set the image tag to point to a branch name and to set the <code>image_pull_policy</code> to alway, for example:</p> <pre><code>image: \"ghcr.io/nesi/training-environment-jupyter-intermediate-shell-app:dev\"\nimage_pull_policy: \"Always\"\n</code></pre> <p>This way, whenever you push a change to the dev branch in your app repo, it will rebuild the docker image with the dev tag and then you can just restart your app in the training environment to pick up the changes. Do not do this in production though, pulling images can be slow.</p> <p>UNFINISHED</p>"},{"location":"tutorials/jupyterlab-app-for-intermediate-shell-for-bioinformatics/#viewhtmlerb","title":"view.html.erb","text":"<p>The view.html.erb file contains the html form with a button that the users clicks to connect to the app once it has started (this is the button that shows up in the Open OnDemand user interface). Most of this file should not need to change unless you switch to using a different underlying web application, i.e. RStudio vs JupyterLab.</p> <p>When the form is submitted it redirects the user to the link specified in the action. Here the <code>&lt;%= host %&gt;</code> and <code>&lt;%= port %&gt;</code> are ruby variables that get inserted when the view.html.erb file is run through the ERB template engine to generate view.html.</p> <pre><code>&lt;form action=\"/node/&lt;%= host %&gt;/&lt;%= port %&gt;/login\" method=\"post\" target=\"_blank\"&gt;\n</code></pre> <p>For a JupyterLab app we need to pass through the password that was set during initialisation of the app, otherwise the user would have to manually input it. This is achieved using a hidden input on the form and the <code>&lt;%= password %&gt;</code> ruby variable:</p> <pre><code>&lt;form action=\"/node/&lt;%= host %&gt;/&lt;%= port %&gt;/login\" method=\"post\" target=\"_blank\"&gt;\n  &lt;input type=\"hidden\" name=\"password\" value=\"&lt;%= password %&gt;\"&gt;\n</code></pre> <p>The only line we may want to change in this file is the text that will be shown on the button:</p> <pre><code>&lt;form action=\"/node/&lt;%= host %&gt;/&lt;%= port %&gt;/login\" method=\"post\" target=\"_blank\"&gt;\n  &lt;input type=\"hidden\" name=\"password\" value=\"&lt;%= password %&gt;\"&gt;\n  &lt;button class=\"btn btn-primary\" type=\"submit\"&gt;\n    &lt;i class=\"fa fa-registered\"&gt;&lt;/i&gt; Connect to Intermediate Shell app\n  &lt;/button&gt;\n&lt;/form&gt;\n</code></pre>"},{"location":"tutorials/jupyterlab-app-for-intermediate-shell-for-bioinformatics/#templatescriptsherb","title":"template/script.sh.erb","text":""},{"location":"tutorials/jupyterlab-app-for-intermediate-shell-for-bioinformatics/#dockerdockerfile","title":"docker/Dockerfile","text":""}]}